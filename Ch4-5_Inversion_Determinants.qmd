---
title: "Chapter - Matrix Determinants"
author: "Rodolfo León"
format: 
  pdf:
    code-fold: true
    code-tools: true
---

# Matrix Notebook
This notebook contains matrices for exercises drawn from **Schaum's Matrix Operations** (and other Schaum volumes).

It serves as an **organized workbook** you can use for:
- LU decomposition (Crout, Doolittle, pivoting)
- Solving Ax = b
- Determinants
- Matrix inverses
- REF / RREF
- Rank
- Other linear algebra routines

All computations use the functions defined in:
functions/matrix_tools.R

```{r}
knitr::opts_knit$set(root.dir = "C:/Users/rodol/OneDrive/Documents/Schaums-mastery/matrices_R", echo = TRUE, warning = FALSE, message = TRUE)
```

```{r}
source("functions/matrix_tools.R")
library(pander)
```

```{r}
panderOptions('table.split.table', Inf)   # Avoid splitting tables across pages
panderOptions('table.style', 'multiline') # Enable multiline cell text wrapping
panderOptions('table.alignment.default', 'center') # Align text to the center
panderOptions('table.alignment.rownames', 'left') # Align row names (first column) to the left
panderOptions('table.emphasize.rownames', FALSE)  # Remove the ** from row names
panderOptions("digits", 6)
```

-------------------------------------------------------

# crout_decomposition()  (L has 1s on diagonal)
# crout_decomposition_pivoting()
# solve_lu()
# det_lu()
# matrix_inverse()
# doolittle_decomposition()  (U has 1s on diagonal)
# doolittle_decomposition_pivoting ()
# solv_doolittle()
# solve_doolittle_pivot()
# det_doolittle()
# det_doolittle_pivot
# inverse_doolittle()
# inverse_doolittle_pivot()
# row_echelon_form()  REF/RREF
# rank_lu()
# matvec()
# run_full_analysis() 

-------------------------------------------------------

# -----------------------------------------------------
# Matrix Inversion using Doolittle's Method
# -----------------------------------------------------

```{r}
# 4.3 Determine the inverse
A = matrix(c(2,1,3,
             0,1,2,
             0,0,3), 
           nrow = 3, byrow = TRUE)

invD <- inverse_doolittle(A)
pander("Inverse Doolittle of A:")
pander(invD)
pander("Verification (A %*% invD):")
pander(A %*% invD)

pander("Verification (A %*% invA):")
         
```

```{r}
# 4.4a Determine the inverse
B = matrix(c(3,0,0,0,
             1,-2,0,0,
             2,4,1,0,
             1,3,-1,0),
           nrow = 4, byrow = TRUE)

invD <- inverse_doolittle(B)
pander("Inverse Doolittle of B:")
pander(invD)
pander("Verification (B %*% invD):")
pander(B %*% invD)
# Since the matrix has '0' in the diagonal, it does not have an inverse.
```

```{r}
# 4.4b Determine the inverse
C = matrix(c(1,0,0,0,
             2,-2,0,0,
             3,1,-2,0,
             1,-1,3,3),
           nrow = 4, byrow = TRUE)

invD <- inverse_doolittle(C)
pander("Inverse Doolittle of C:")
pander(invD)
pander("Verification (C %*% invD):")
pander(C %*% invD)
```

# -----------------------------------------------------
# Solve Systems of Equations using Doolittle's Method
# -----------------------------------------------------

```{r}
# 4.8 Solve the system
A = matrix(c(5,3,
             2,1), 
           nrow = 2, byrow = TRUE)

b = c(8, -1)

section("Solve Ax = b (Doolittle, no pivot)")
x_d <- solve_doolittle(A, b)
pander("\nx_d = ")
x_d
pander("\n### Verification (A %*% x):")
A %*% x_d
```

```{r}
# 4.9a Solve the system - Doolittle
A = matrix(c(0,1,1,
             5,1,-1,
             2,-3,-3), 
           nrow = 3, byrow = TRUE)

b = c(2,3,-6)

# Solve Ax = b with pivoted Doolittle
section("Solve A_piv x = b_piv (Doolittle pivoted)")
x_dp <- solve_doolittle_pivot(A_piv, b_piv)
pander("\nx_dp = ")
x_dp
stopifnot(ae(as.numeric(A_piv %*% x_dp), as.numeric(b_piv)))
pander("\n### Verification (A %*% x):")
A %*% x_dp
```

```{r}
# 4.9b Solve the system - Crout pivoted
A = matrix(c(0,1,1,
             5,1,-1,
             2,-3,-3), 
           nrow = 3, byrow = TRUE)

b = c(2,3,-6)


section("Solve A_piv x = b_piv (Crout pivoted)")
b2_cp <- P_cp %*% b_piv
y_cp  <- forward_substitution(L_cp, b2_cp)
x_cp  <- backward_substitution(U_cp, y_cp)
pander("\nx_cp = ")
x_cp
stopifnot(ae(as.numeric(A_piv %*% x_cp), as.numeric(b_piv)))
pander("\n### Verification (A %*% x):")
A %*% x_cp
```

```{r}
# 4.29a Solve the system - Crout and Doolittle no pivot
A = matrix(c(2,2,3,3,
             2,3,3,2,
             5,3,7,9,
             3,2,4,7), 
           nrow = 4, byrow = TRUE)

b = c(1,1,1,1)

section("Solve Ax = b (Doolittle, no pivot)")
x_d <- solve_doolittle(A, b)
pander("\nx_d = ")
x_d
pander("\n\n### Verification (A %*% x_c):")
pander(A %*% x_c)



section("Solve Ax = b (Crout, no pivot)")
x_c <- solve_lu(A, b)
pander("\nx_c = ")
x_c
stopifnot(ae(as.numeric(A %*% x_c), as.numeric(b)))
pander("\n\n### Verification (A %*% x_c):")
pander(A %*% x_c)

```

```{r}
# 4.29b Solve the system - Decompose the matrix with Crout LU with Partial Pivoting
A = matrix(c(2,2,3,3,
             2,3,3,2,
             5,3,7,9,
             3,2,4,7), 
           nrow = 4, byrow = TRUE)

b = c(1,1,1,1)

section("Crout LU with Partial Pivoting on A")

lu_cp <- crout_decomposition_pivoting(A)
P_cp  <- lu_cp$P
L_cp  <- lu_cp$L
U_cp  <- lu_cp$U

pander("P (Crout pivot)")
pander(P_cp)
pander("L (Crout pivot)")
pander(L_cp)
pander("U (Crout pivot)")
pander(U_cp)

section("Check: P %*% A ≈ L * U (Crout pivoted)")
PA_cp <- P_cp %*% A
LU_cp <- L_cp %*% U_cp
pander("P_cp %*% A")
pander(PA_cp)
pander("L_cp %*% U_cp")
pander(LU_cp)

stopifnot(ae(as.numeric(PA_cp), as.numeric(LU_cp)))

```

```{r}
# 4.29c Solve Ax = b with pivoted Crout
section("Solve Ax = b (Crout pivoted)")
b2_cp <- P_cp %*% b
y_cp  <- forward_substitution(L_cp, b2_cp)
x_cp  <- backward_substitution(U_cp, y_cp)
pander("\nx_cp = ")
pander(x_cp, style = "simple")
#stopifnot(ae(as.numeric(A %*% x_cp), as.numeric(b)))
pander("\n\n### Verification (A %*% x_cp):")
pander(A %*% x_cp)
```

```{r}
# 4.29b Solve the system - Decompose the matrix with Doolittle LU with Partial Pivoting
A = matrix(c(2,2,3,3,
             2,3,3,2,
             5,3,7,9,
             3,2,4,7), 
           nrow = 4, byrow = TRUE)

b = c(1,1,1,1)

section("Doolittle LU Decomposition (no pivot) on A")

lu_d <- doolittle_decomposition(A3)
L_d  <- lu_d$L
U_d  <- lu_d$U

pander("\nL (Doolittle)")
pander(L_d)
pander("\nU (Doolittle)")
pander(U_d)

# Check reconstruction
section("Check: Doolittle L * U ≈ A")
LUd <- L_d %*% U_d
pander(LUd)
stopifnot(ae(as.numeric(LUd), as.numeric(A)))

```

```{r}
section("Solve Ax = b (Doolittle, no pivot)")
x_d <- solve_doolittle(A, b)
pander("\nx_d = ")
cat(x_d)
Ax_d <- A %*% x_d

stopifnot(ae(as.numeric(Ax_d), as.numeric(b)))
pander("\n\n### Verification (A %*% x):")
pander(Ax_d)
```


# -----------------------------------------------------
# Matrix Determinants
# -----------------------------------------------------

```{r}
# 5.1a Calculate determinant
A = matrix(c(1,2,
             3,4),
            nrow=2, byrow=TRUE)
section("det(A) via Doolittle vs base::det")
det_d <- det_doolittle(A)
pander("\nDeterminant of A: ")
cat(det_d)
stopifnot(ae(det_d, det(A)))
```

```{r}
B = matrix(c(2,-3,
             4,5),
            nrow=2, byrow=TRUE)
section("det(B) via Doolittle vs base::det")
det_d <- det_doolittle(B)
pander("\nDeterminant of B: ")
cat(det_d)
stopifnot(ae(det_d, det(B)))
```

```{r}
C = matrix(c(2,3,4,
             -5,5,6,
             7,8,9), nrow=3, byrow=TRUE)

section("det(C) via Doolittle vs base::det")
det_d <- det_doolittle(C)
pander("\nDeterminant of C: ")
cat(det_d)

```

```{r}
D = matrix(c(1,-4,2,-2,
             4,7,-3,5,
             3,0,8,0,
             -5,-1,6,9), 
           nrow = 4, byrow = TRUE)

section("det(D) via Doolittle vs base::det")
det_d <- det_doolittle(D)
pander("\nDeterminant of D:")
cat(det_d)

```

```{r}
E = matrix(c(1,2,-3,4,
             2,-2,5,-6,
             -1,3,-4,6,
             6,5,-3,6),
           nrow = 4, byrow = TRUE)

section("det(E) via Doolittle vs base::det")
det_e <- det_doolittle(E)
pander("\nDeterminant of E = ")
if (det_e < 1e-16) {
  cat(round(det_e,0))
  cat("\nThe matrix is singular = non invertible.")
} else {
  cat(det_e)
}

```

